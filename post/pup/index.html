<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.82.1" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	
	<meta property="og:title" content="PUP : Price-aware Recommendation Convolution Network 리뷰">
	
	
	<meta name="keywords" content="Recsys,GNN,GCN,Price,PUP,Beibei"><meta name="description" content="ABSTRACT 최근의 추천은 유저 행동을 마이닝 하는 연구가 많았다.
→ 유저 들이나 아이템 들을 설명하는 텍스트 정보, 데모그라픽, 이미지 등의 일반적인 정보를 다루는 CF.
마케팅에서 중요하게 여기는 가격은 유저의 최종적인 구매를 결정하지만, 상 …"><meta property="og:title" content="PUP : Price-aware Recommendation Convolution Network 리뷰" />
<meta property="og:description" content="ABSTRACT 최근의 추천은 유저 행동을 마이닝 하는 연구가 많았다.
→ 유저 들이나 아이템 들을 설명하는 텍스트 정보, 데모그라픽, 이미지 등의 일반적인 정보를 다루는 CF.
마케팅에서 중요하게 여기는 가격은 유저의 최종적인 구매를 결정하지만, 상대적으로 관심을 받지 못했다.
→ 따라서 본 연구에서는 가격에 집중해서 유저의 구매 의도를 예측하는 추천 메소드 개발을 목표로 한다.
연구가 가지는 두가지 어려움은 다음과 같다.
 가격에 대한 유저의 선호도와 민감도가 알려지지 않았다. 과거 유저가 구매 아이템에 암시적으로 반영되어있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pko89403.github.io/post/pup/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-19T12:14:52&#43;09:00" />
<meta property="article:modified_time" content="2022-03-19T12:14:52&#43;09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PUP : Price-aware Recommendation Convolution Network 리뷰"/>
<meta name="twitter:description" content="ABSTRACT 최근의 추천은 유저 행동을 마이닝 하는 연구가 많았다.
→ 유저 들이나 아이템 들을 설명하는 텍스트 정보, 데모그라픽, 이미지 등의 일반적인 정보를 다루는 CF.
마케팅에서 중요하게 여기는 가격은 유저의 최종적인 구매를 결정하지만, 상대적으로 관심을 받지 못했다.
→ 따라서 본 연구에서는 가격에 집중해서 유저의 구매 의도를 예측하는 추천 메소드 개발을 목표로 한다.
연구가 가지는 두가지 어려움은 다음과 같다.
 가격에 대한 유저의 선호도와 민감도가 알려지지 않았다. 과거 유저가 구매 아이템에 암시적으로 반영되어있다."/>
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<link rel="stylesheet" href="/css/katex.min.css" crossorigin="anonymous">
	<script defer src="/js/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="/js/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
	<script>
		document.addEventListener("DOMContentLoaded", function() {
			renderMathInElement(document.body, {
				delimiters: [
					{left: "$$", right: "$$", display: true},
					{left: "$", right: "$", display: false}
				]
		});
		});
	</script><title>PUP : Price-aware Recommendation Convolution Network 리뷰 | 유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?</title>


</head>
<body><header>
	
	<div id="avatar">
		<a href="https://pko89403.github.io/">
		  <img src="/img/Avatar.png" alt="유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://pko89403.github.io/">유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?</a></h2></div>
	<div id="title-description"><p id="subtitle"><a href=""></a></p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/pko89403"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:pko89403@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/">Home</a></li>
				
				<li><a href="/post">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/tags">Tags</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">19</span>
				<span class="rest">Mar 2022</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">PUP : Price-aware Recommendation Convolution Network 리뷰</h1>
		</div>
	</div>
	<div class="markdown">
		<h1 id="abstract">ABSTRACT</h1>
<p>최근의 추천은 유저 행동을 마이닝 하는 연구가 많았다.</p>
<p>→ 유저 들이나 아이템 들을 설명하는 텍스트 정보, 데모그라픽, 이미지 등의 일반적인 정보를 다루는 CF.</p>
<p>마케팅에서 중요하게 여기는 가격은 유저의 최종적인 구매를 결정하지만, 상대적으로 관심을 받지 못했다.</p>
<p>→ 따라서 본 연구에서는 가격에 집중해서 유저의 구매 의도를 예측하는 추천 메소드 개발을 목표로 한다.</p>
<p>연구가 가지는 두가지 어려움은 다음과 같다.</p>
<ol>
<li>가격에 대한 유저의 선호도와 민감도가 알려지지 않았다. 과거 유저가 구매 아이템에 암시적으로 반영되어있다.</li>
</ol>
<p>유저-아이템 과 아이템-가격 간의 관계를 GCN으로 모델링 한다. 유저에게 가격의 영향도를 아이템을 브릿지로 사용해 전파하고, 가격을 인식한(price-aware) 유저 표현을 학습한다.</p>
<ol>
<li>가격은 제품 카테고리에 의존해 유저에 영향을 미친다.</li>
</ol>
<p>아이템 카테고리를 전파 과정에 통합시키고 유저-아이템 상호작용을 예측하기 위해 가능한 상호작용 쌍을 모델링한다.</p>
<p>실제 두 데이터셋을 사용해 실험을 한다. GCN 기반 메소드가 가격을 고려한 유저의 선호도를 효과적으로 학습한다는 것을 증명한다. 후속 분석에서 가격을 고려한 모델링이 미관측 카테고리에 대해 유저 선호도를 예측하는데 유용 하다는 것을 보인다.</p>
<h1 id="1-introduction">1. INTRODUCTION</h1>
<p>이커머스 제품과 레스토랑 메뉴는 경제적 비용을 고려해 제공 되기 때문에 유저의 고유한 관심사 뿐만이 아니라, 아이템 가격도 유저의 최종 구매 결정을 내릴지 여부를 결정하는데 중요한 역할을 한다.</p>
<p>→ 마케팅 분야의 연구에서는 이미 가격이 유저의 행동과 판매에 많은 영향을 끼친다는 것이 알려졌지만, 추천에서는 관심을 상대적으로 받지 못했다.</p>
<p>유저의 관심사(interest)에 영향을 미치는 제조사와 태그들 같은 다른 아이템 속성과 다르게, 아이템 가격은 유저가 결제할 의도 ( Willing To Pay, WTP )에 영향을 미친다. 다르게 말하면, 가격과 다른 속성 들은 유저 결정 과정에 직교 역할을 한다.</p>
<p>→ 아이템이 흥미롭고 가격이 합리적이면 유저가 구매할 것이다.</p>
<p>가격을 추천 시스템에 효과적으로 통합시키는 데는 두 가지 어려움이 있다.</p>
<ul>
<li>
<p><strong>Unstated price awareness</strong>. 유저가 아이템 가격에 대한 선호도와 민감도를 명시적으로 드러내지 않는다.</p>
<ul>
<li>구매 히스토리에서 가격에 대한 유저의 개인적인 인식을 추론해야 한다.</li>
<li>추론 정확도를 높이기 위해 유사한 유저의 히스토리에 반영된 CF 효과를 고려해야 한다.</li>
</ul>
</li>
<li>
<p><strong>Category-dependent influence</strong>. 아이템 카테고리에 따라 유저의 가격 인식과 가격을 감당 가능한 정도가 달라진다.</p>
<p>→ 운동을 좋아하면 운동 장비에 대해 높은 가격을 감당할 수 있지만, 술에는 아니다.</p>
<ul>
<li>카테고리가 유저의 가격 선호도를 추론하기 위해 함께 고려 되어야 한다.</li>
</ul>
</li>
</ul>
<p>아이템의 사이드 정보로 가격이 추가 될 수 있지만, 유저 결정에 미치는 독특한 영향을 무시한다.</p>
<ul>
<li>특별히 설계 되지 않았기 때문에 가격 민감도가 적절하게 포착 되었는지 여부를 알 수 가 없다.</li>
</ul>
<p>본 연구에서는 GCN을 적용해 카테고리에 의존한 가격 인식을 포함하는 유저 표현을 학습하는 PUP 이라는 솔루션을 제시해서 위 두 어려움을 해결한다.</p>
<p>구체적으로는 가격 변수를 네 타입의 노드로 구성된 그래프( heterogeneous )를 구성한다.</p>
<ul>
<li>유저, 아이템, 가격, 카테고리</li>
</ul>
<p>위의 노드들은 아래와 같이 연결 된다.</p>
<ul>
<li>유저 - 아이템, 아이템 - 가격, 아이템 - 카테고리</li>
</ul>
<p>아이템을 브릿지로 사용해서 가격에서 유저로 임베딩을 전파해서 유저에 간접적으로 가격의 영향을 간접적으로 인코딩한다.</p>
<ul>
<li>유저 - 아이템 - 가격</li>
</ul>
<p>→ 유저 임베딩을 가격 임베딩과 연관해 유저와 유저가 자주 구매하는 가격에 높은 연결성을 부여한다.</p>
<p>추가로 유저 임베딩을 아이템과 가격에 전파하고 그 과정에 카테고리를 통합한다. → CF 효과, 카테고리 관련성</p>
<p>상호 작용 쌍에 기반한 디코더로 유저, 아이템, 가격, 카테고리에 대한 상호작용을 포착한다.</p>
<p>마지막으로, 전체 모델은 end-to-end 방식으로 학습되고 소비 행동을 예측하는 방식으로 최적화 한다. 이러한 설계로 PUP 메소드는 복잡한 가격 정보를 효과적으로 포함 시킨다.</p>
<p>본 논문의 두가지 기여는 아래와 같다.</p>
<ul>
<li>추천에서 가격의 중요성을 강조하고, 유저 선호도를 학습을 위한 아이템 가격과 카테고리를 통합하는 그래프 기반 솔루션을 제안한다.</li>
<li>실제 데이터 셋으로 메소드를 검증한다. 추가 분석으로 콜드 스타트 시나리오에서 가격을 모델링하고 처음 보는 카테고리의 아이템을 추천하는 기능을 증명한다.</li>
</ul>
<h1 id="2-motivation-and-problem-formulation">2. MOTIVATION AND PROBLEM FORMULATION</h1>
<h2 id="a-preliminary-study">A. Preliminary Study</h2>
<p>실제 데이터 셋(중국 커머스 데이터)으로 가격 민감도가 카테고리에 영향을 미치는지 확인하는 통계적 분석을 수행한다.</p>
<p>카테고리에 따라 다른 가격 민감도를 이해하기 위해 WTP를 CWTP로 확장한다.</p>
<ul>
<li>WTP(지불 의향성) : 유저가 지불할 의사가 있는 아이템 최고 허용 가격으로 정의된다.</li>
<li>CTWP(카테고리 지불 의향성) : 유저가 지불할 의사가 있는 아이템 들의 카테고리에서 가장 높은 가격으로 정의한다. 여러 카테고리와 상호작용한 유저는 CWTP 여러 개의 값을 가지게 된다.</li>
</ul>
<p>CWTP 들의 엔트로피를 계산한다.</p>
<ul>
<li>엔트로피 $\downarrow$ : 유저의 가격 민감도가 카테고리에 영향을 받지 않는다.</li>
<li>엔트로피 $\uparrow$ : 유저의 가격 민감도가 카테고리에 영향을 받는다.</li>
</ul>
<p>그림 1은 전체 유저에 대한 엔트로피의 히스토그램을 그린다.</p>
<figure>
    <img src="/images/PUP/0.png"/> <figcaption>
            <h4>Figure 1</h4>
        </figcaption>
</figure>

<p>한쪽으로 쏠린 분포 → 가격과 카테고리가 관련성이 높다.</p>
<p>추가로 데이터셋 에서 세 유저를 랜덤하게 샘플링해서 그림 2에 가격-카테고리인 상호작용 히스토리를 나타낸다.</p>
<figure>
    <img src="/images/PUP/1.png"/> <figcaption>
            <h4>Figure 2</h4>
        </figcaption>
</figure>

<ul>
<li>X : 가격 수준 ( 10 )</li>
<li>Y : 카테고리 ( 110 )</li>
</ul>
<p>카테고리 별 가격 수준이 하나로 집중 됨을 보인다 → 유저의 가격 민감도가 카테고리에 밀접한 관련이 있다</p>
<p>게다가 그림 1의 엔트로피 분포와 함께 보면, 특정 카테고리에서는 가격이 낮은 아이템을 구입할 가능성이 높지만, 다른 카테고리는 높은 가격의 제품을 구매한다.</p>
<p><strong>요약</strong>. 거시 수준과 미시 수준 통계 분석으로 가격의 효과가 카테고리와 관련되어 있으며, 이 민감도가 카테고리 별로 다르다는 것을 발견했다. 카테고리 의존한 가격 인식의 중요성을 검증했다. 추천에서 가격을 모델링 하기 어렵게 만든다.</p>
<h2 id="b-problem-definition">B. Problem Definition</h2>
<p>카테고리와 유저의 가격 인식이 서로 밀접한 관계이기 때문에 가격 인식 추천 시스템 설계에 카테고리를 고려가 필수적이다.</p>
<p>문제는 아래와 같이 공식화 할 수 있다.</p>
<ul>
<li>유저 셋 : $U$</li>
<li>아이템 셋 : $I$</li>
<li>유저 아이템 상호작용 매트릭스 : $R_{M \times N}$ ( M : 유저 수, N : 아이템 수 )</li>
<li>유저 $u$가 아이템 $i$를 한번 구매 : $R_{ui} = 1$</li>
<li>아이템 가격 : $p = {{ p_1, p_2, &hellip;, p_N }}$</li>
<li>아이템 카테고리 : $c = {{ c_1, c_2, &hellip;, c_N }}$</li>
</ul>
<p>가격은 균일하게 양자화($uniform \ quantization$)한 카테고리 변수로 사용한다.</p>
<p>모바일 폰 카테고리의 가격 범위가 [200, 3000]이고 10개 가격 레벨로 나눈다. 그러면 가격 1000은 2가 된다.</p>
<p>예) $[ {\frac{1000 - 200}{3000 - 200}} \times 10] = [2.8&hellip;] = 2$</p>
<p>가격 인식 아이템 추천을 최종적으로 아래와 같이 공식화 한다.</p>
<ul>
<li><strong>Input</strong> : 상호작용 매트릭스 $R$, 아이템 가격 $p$, 아이템 카테고리 $c$</li>
<li><strong>Output</strong> :  유저-아이템 쌍 $(u, i)$에 대해 예측된 구매 확률</li>
</ul>
<h1 id="3-method">3. METHOD</h1>
<p>PUP 모델은 그림 3에 있다.</p>
<figure>
    <img src="/images/PUP/2.png"/> <figcaption>
            <h4>Figure 3</h4>
        </figcaption>
</figure>

<p><strong>모델의</strong> <strong>입력</strong> : 유저-아이템 쌍 $(u, i)$,  아이템의 두 어트리뷰트 $&lt; p_i, c_i &gt;$</p>
<p><strong>모델의 출력 :</strong> 유저 $u$가 아이템 $i$를 소비할 likelihood</p>
<p>PUP 메소드는 크게 세가지를 가진다.</p>
<ul>
<li><strong>통합 heterogeneous 그래프</strong>. 유저 행동과 아이템 어트리뷰트의 명시적인 모델링을 위해 가격을 나눈 네가지 타입의 노드를 가지는 그래프를 생성한다. 알려지지 않은 가격 인식 문제를 해결하기 위해 명시적인 가격 노드를 로 추가한다. 카테고리 의존을 고려하기 위해 카테고리 노드를 추가한다.</li>
<li><strong>그래프 컨볼루션 인코더</strong>. CF 효과와 가격 인식을 위해, GCN을 활용한 인코더를 사용한다. 유저, 아이템, 가격, 카테고리 벡터를 학습한다. 그래프 구조로 임베딩을 전파한다. 유저 노드에 가격 인식 정보를 집계해서 유저의 가격 민감도를 포함시킨다.</li>
<li><strong>양방향 상호작용 기반 디코더</strong>. 그래프는 FM의 철학에서 영감을 받아 공유된 잠재 공간으로 분해되는 종류의 노드로 구성되기 때문에, 상호작용 확률을 예측하기 위해 상호작용 쌍 기반 디코더를 적용한다.</li>
</ul>
<p>추천에 복잡한 가격 요소를 포함시키기 위해서, 브랜치 두개를 사용해서 카테고리에 의존적이고 가격이 인식된 유저 선호도를 예측한다.</p>
<ul>
<li><strong>글로벌 브랜치</strong> : 유저의 관심사에 집중하고 가격을 글로벌 효과를 가지도록 모델링 해서 카테고리와 관계가 없는 유저의 전체적인 구매력을 표현한다.</li>
<li><strong>카테고리 브런치</strong> : 카테고리에 의존적인 가격의 효과에 집중한다.</li>
</ul>
<p>→ 브랜치 마다 그래프를 생성하고 그래프 컨볼루션 인코더를 적용하고 상호작용 쌍 디코더를 적용한다. 간소화를 위해, 단일 브랜치 방식으로 메소드를 소개한다. 두 브랜치 버전은 같은 형태이다.</p>
<h2 id="a-unified-heterogeneous-graph">A. Unified Heterogeneous Graph</h2>
<p>유저-아이템 상호작용 데이터와 아이템 가격 어트리뷰트를 가지고 있지만, 유저와 가격이 직접적으로 관련되지 않기 때문에, 유저의 가격 인식을 명시적으로 파악하는 건 어렵다.</p>
<ul>
<li><strong>가격 - 유저</strong> 의 관계가 <strong>유저 - 아이템</strong>과 <strong>아이템 - 가격</strong>의 전이 관계로 생성된다.</li>
</ul>
<p>복잡한 관계 파악을 위해, 아이템을 유저와 가격을 연결시키는 브릿지로 사용한다. 따라서 가격 변수를 나눈 네가지 타입의 노드 유저, 아이템, 가격, 카테고리로 구성된 그래프를 생성한다.</p>
<figure>
    <img src="/images/PUP/3.png"/> <figcaption>
            <h4>Unified Heterogeneous Graph</h4>
        </figcaption>
</figure>

<p>입력 상호작용 데이터와 아이템 어트리뷰트( 카테고리, 가격 )가 무방향성 그래프 $G=(V,E)$로 표현된다.</p>
<ul>
<li>노드 : $V$
<ul>
<li>유저 노드 : $u \in U$</li>
<li>아이템 노드 : $i \in I$</li>
<li>카테고리 노드  : $c \in c$</li>
<li>가격 노드 : $p \in p$</li>
</ul>
</li>
<li>엣지 : $E$
<ul>
<li>상호작용 엣지 : $(u, i)$, $R_{ui} = 1$</li>
<li>카테고리 엣지 : $(i, c_i)$, $i \in I$</li>
<li>가격 엣지 : $(i, p_i)$, $i \in I$</li>
</ul>
</li>
</ul>
<p>카테고리와 가격 노드 타입은 나누었기 때문에 두 가지 상황을 표현할 수 있다.</p>
<ul>
<li>(동일 카테고리, 다른 가격 아이템) → 기능적인 유사도</li>
<li>(같은 가격 아이템, 다른 카테고리 ) → 가격 인식 유사도</li>
</ul>
<p>카테고리와 가격에 서로 다른 노드 타입을 적용해 다양한 의미론적 유사도를 그래프에 포함 시킬 수 있다.</p>
<p>→ 노드 분류에서는 그래프 컨볼루션 네트워크에 워드 임베딩 같은 고 수준의 피처 벡터를 노드의 입력 피처로 흔하게 사용한다. 동일한 방식으로, 가격과 카테고리 정보를 유저 노드와 아이템 노드의 입력 피처로 인코딩 하는 것이 합리적으로 보이며, 간결하다. 그러나 본 연구에서는 두 중요한 어트리뷰트를 명시적인 엔티티 노드로 빼내어 카테고리에 의존적인 가격 인식을 더 잘 표현한다. FM의 철학과 일치하는 네가지 유형의 노드를 포함하는 그래프의 명시적 설계 덕분에, 모든 특징 간의 상호작용을 직관적이고 효과적으로 모델링 할 수 있다.</p>
<p>가격과 카테고리가 직접적이고 명시적으로 할당된 분리된 노드로 포함되어 아이템 가격 인식 추천의 두가지 어려움이 완화된다.</p>
<ul>
<li>구체적으로 언급되지 않는 가격 인식 이슈는 그래프 상에서 고차원의 근접 이웃으로 변환되어 GCN에 의해 잘 포함된다.</li>
<li>카테고리 의존 이슈는 아이템 노드를 가격 노드와 카테고리 노드와 연결함으로써 해결된다.</li>
</ul>
<h2 id="b-graph-convolutional-encoder">B. Graph Convolutional Encoder</h2>
<p>LFM을 확장시켜 동일한 사후 공간에 네가지 타입의 엔티티 들의 표현을 학습한다.</p>
<blockquote>
<p>Latent factor model (LFM)은 저차원의 잠재 공간으로 엔티티를 인코딩하는 메커니즘이다. 대표적인 LFM인 FM로 관측된 $(u, i)$ 쌍의 $u$와 $i$를 각 잠재 공간으로 푸쉬한다.</p>
</blockquote>
<p>PUP에서 생성한 그래프에는 $(i,p), (i,c)$ 두 쌍과 $(u,p)$ 같은 유저 $u$가 아이템 $i$를 가격 $p$로 구매 했을 때의 유저-가격 상호작용이 있다는 점이 다르다.</p>
<p>따라서 인코딩 모듈은 다음과 같이 구성된다.</p>
<ul>
<li>원-핫 입력을 저차원 벡터로 변환하는 임베딩 레이어</li>
<li>CF 효과와 가격 인식 모두를 포함하기 위한 임베딩 전파 레이어</li>
<li>이웃 유사성을 모델링 하기 위한 이웃 집계 레이어로 구성된</li>
</ul>
<p><strong>Embedding Layer</strong>. 노드의 피처로 ID만 가진다(가격 노드, 카테고리 노드). 그래서 원-핫 아이디가 벡터로 변환되는 임베딩 레이어를 사용한다. 즉, 각 노드를 분리된 $d$ 차원의 임베딩 $e^{`} \in R^d$로 표현한다.</p>
<p><strong>Embedding propagation layer</strong>. GCN은 노드의 임베딩을 그들의 첫번째 이웃으로 전파한다. 레이어 하나가 더 적용되면 다음 번째 이웃으로 전파된다. 임베딩 전파 레이어는</p>
<ul>
<li>(유저 - 아이템), (아이템 - 가격), (아이템 - 카테고리)</li>
</ul>
<p>직접 연결된 두 노드로 메시지를 전파한다. 노드 $i$와 노드 $j$를 그래프 내 연결된 두 노드로 가정하면 노드 $j$에서 노드 $i$로 전파된 임베딩은 아래와 같이 공식화 된다.</p>
<figure>
    <img src="/images/PUP/4.png"/> 
</figure>

<ul>
<li>$N_i$ : 노드 $i$의 이웃 셋</li>
<li>$e_j^’$ : 임베딩 레이어로 부터 검색된 노드 $j$의 임베딩</li>
</ul>
<p>셀프 루프를 추가가 GCN에 중요한데 정규화된 라플라시안의 스펙트럼을 줄이기 때문이다. 그래서 그래프의 각 노드를 $N_i$에 등장하는 노드 그 자체에도 연결한다.</p>
<p><strong>Neighbor aggregation layer</strong>. 네트워크 표현 학습에서, 그래프 구조 내 두 노드의 이웃 관계는 그들의 관계가 잠재 공간에서 가까이 위치해야 한다는 것을 의미한다. GCN에 영감을 받아, 이웃 노드의 표현을 집계해서 노드 표현을 업데이트 했다. 집계 연산 중 합, 평균, LSTM은 가장 빈번하게 사용되는 방법이다.</p>
<p>→ PUP의 인코더 에서는, 평균 풀링과 비선형 활성화 함수를 활용해서 그래프의 메시지 패싱을 수행한다.</p>
<p>서로 다른 노드 타입의 업데이트 규칙은 그림 4와 같다.</p>
<figure>
    <img src="/images/PUP/5.png"/> <figcaption>
            <h4>Figure 4</h4>
        </figcaption>
</figure>

<p>위의 업데이트 규칙은 아래와 같이 공식화 된다.</p>
<figure>
    <img src="/images/PUP/6.png"/> 
</figure>

<p>임베딩 전파와 이웃 집계로 그래프 컨볼루션 인코더로 추출된 표현이 노드와 그 고차 이웃과의 관계를 효과적으로 모델링할 수 있다</p>
<blockquote>
<p>동일한 가격대의 아이템들의 유사도가 다른 가격대의 아이템 보다 더 높다</p>
</blockquote>
<p>그래프에서 가격 노드가 모든 아이템 노드와 연결되고, 그래프 컨볼루션 인코더는 임베딩 전파와 이웃 집계로 그러한 아이템들의 출력 표현에 가격 임베딩이 포함 되었다는 것을 보장한다.</p>
<p>그래서, 인코더가 가격 인식 유사도를 가지는 아이템 표현을 생성한다. 카테고리 노드가 해당 카테고리에 속하는 모든 아이템 노드에 연결되기 때문에 카테고리 인식 유사성도 동일한 방법으로 진행된다.</p>
<p>게다가, 유저의 가격 인식이 CF를 통해 유저와 상호작용한 아이템과 다른 유저의 구매 히스토리를 강하게 반영한다. 그래서 아이템을 유저와 가격 인식 간의 브릿지로 활용하는 점이 중요하다.</p>
<p>→ PUP 모델에서, 유저 표현은 상호작용한 아이템들로 명시적으로 집계된다. 그리고 아이템은 카테고리와 가격과 집접적으로 연결된다. 그래서 카테고리 노드와 가격 노드는 유저 노드에 대한 고차 이웃 노드이고, 가격 인식은 중간의 아이템 노드를 통해 유저에게 전파된다.</p>
<p>그래프 컨볼루션 인코더는 두 노드 사이에 경로가 존재할 때 두 노드의 유사성을 포착할 수 있다.</p>
<p>기존 MF 알고리즘은 유저-아이템 상호작용 예측을 최적화함으로 CF 효과가 포착된다.</p>
<p>그러나, 그래프 컨볼루션 인코더에서는 명시적으로 CF 효과를 이웃을 집계함으로써 한다.</p>
<p>구체적으로, 동일한 아이템으로 상호작용한 유사한 유저는 그래프 상에서 2차 이웃이기 때문에 그래프 컨볼루션 인코더에 의해 유사도가 포착된다.</p>
<h2 id="c-pairwise-interaction-based-decoder">C. Pairwise-interaction Based Decoder</h2>
<p>추천에 가격을 통합 하기 위해 유저-아이템 상호작용 예측에 브랜치 두개를 설계한다.</p>
<ol>
<li><strong>글로벌 브랜치</strong> : 넓은 범위의 가격 효과를 모델링해서 유저의 전체 구매력에 집중한다.</li>
<li><strong>카테고리 브랜치</strong> : “로컬&quot;한 수준에 집중해서 카테고리가 유저의 가격 민감도에 영향을 미치는데 집중한다.</li>
</ol>
<p>각각의 브랜치에서 상호작용 쌍 기반 디코더를 적용해서 상호작용 확률을 예측하고 두 예측된 스코어를 결합해서 최종 결과로 사용한다.</p>
<p>그래프의 노드로 유저, 아이템, 카테고리, 가격을 표현한다. 학습된 네 노드는 동일한 잠재 공간을 공유한다. FM에 영감을 받아, 디코더도 FM 방식을 적용한다.</p>
<blockquote>
<p>FM은 모든 피처를 공유된 사후 공간에 분해하고 모든 피처 벡터의 쌍을 내적으로 상호작용을 예측한다.</p>
</blockquote>
<p>유저 $u$, 아이템 $i$의 카테고리 $c$, 아이템 $i$의 가격 $p$는 아래와 같이 공식화된다.</p>
<figure>
    <img src="/images/PUP/7.png"/> 
</figure>

<p>최종 예측 결합은 두 브랜치 결과를 하이퍼 파라미터 $\alpha$로 결합한다. 계산에 사용 되는 $S_{global}$과 $S_{category}$의 임베딩은 서로 다르고 독립적이다( 각 브랜치가 고유한 그래프 컨볼루션 인코더를 가짐 ).</p>
<p><strong>글로벌 브랜치</strong>. 세 피처(유저, 아이템, 가격)가 투-웨이 FM 방식으로 피딩되어 카테고리 임베딩 없이 상호작용 확률을 예측한다. 세 내적 각각은 유저의 관심사, 유저의 글로벌한 가격 효과, 아이템 가격에 대한 바이어스를 포착한다.</p>
<figure>
    <img src="/images/PUP/8.png"/> 
</figure>

<p>카테고리 노드는 정규화 텀으로만 제공되어 그래프 상에 동일한 카테고리의 아이템을 서로 가깝게 만든다. 카테고리 정보가 글로벌 브랜치 내 디코더 과정에서 숨겨져 있어서, 카테고리와 관련된 가격의 “로컬” 효과가 학습된 잠재 공간으로 부터 나온다.</p>
<p>유저의 전체 구매력과 감당 가능한 가격대인 글로벌 가격 효과는 그래프 컨볼루션 인코더로 학습된 잠재 공간에 존재한다.</p>
<p><strong>카테고리 브랜치</strong>. 유저의 가격 민감도는 카테고리에 따라 달라질 수 있다. 따라서 카테고리와 관련된 미묘한 가격 인식을 포착하는 역할을 한다. 아이템 임베딩을 제외하고 유저, 카테고리, 가격로 상호작용을 예측한다.</p>
<figure>
    <img src="/images/PUP/9.png"/> 
</figure>

<p>아이템 노드는 가격과 카테고리 정보를 유저에게 전달하는 브릿지 역할을 한다. 세 임베딩에 내적을 적용해서, 유저의 카테고리에 의존적인 가격 인식이 공유된 잠재 공간에 있다는 것을 보장한다.</p>
<p>→ 디코더는 두-브랜치 디자인이 추천 시스템에서 글로벌한 가격 효과와 카테고리에 의존적인 가격 효과를 분리하므로 가격 인식과 관련하여 뛰어난 해석 가능성을 제공한다.</p>
<h2 id="d-model-training">D. Model training</h2>
<p><strong>Semi-supervised graph auto-encoder</strong>. PUP 모델 학습에 semi-supervised 그래프 오토 인코더 방식을 따른다. 즉 인코딩 스테이지에서 네가지 노드의 강력한 표현을 학습하기 위해 GCN을 활용한다. 디코딩 과정에서는 그래프 상의 유저-아이템 엣지 재구축에 집중한다. 추천이 메인 태스크 이므로 나머지 엣지는 제외한다.</p>
<p><strong>Loss function</strong>. 서로 다른 아이템에 대한 유저의 선호도를 학습하기 위해 BPR 로스 함수를 사용한다.</p>
<blockquote>
<p>BPR은 긍정 샘플(상호작용 함)이 부정 샘플(상호작용 하지 않음)보다 높은 랭크를 가지게 한다. 절대적인 관심사 대신 아이템에 대한 상대적인 선호도 우선순위에 초점을 맞춘다.</p>
</blockquote>
<figure>
    <img src="/images/PUP/10.png"/> 
</figure>

<h1 id="4-implementation">4. IMPLEMENTATION</h1>
<h2 id="a-how-to-perform-graph-convolution">A. How to Perform Graph Convolution?</h2>
<p>그래프 컨볼루션 인코더는 임베딩 레이어, 임베딩 전파 레이어, 이웃 집계 레이어로 구성된다. 메시지 패싱은 세 레이어를 쌓아서 구성된다. 그래프 컨볼루션 인코더는  semi-supervised 접근법과 유사하게 sparse matrix production을 사용해서 효과적으로 구현될 수 있다.</p>
<p>sparse한 rectified adjacency matrix $\hat{A}$를 아래와 같이 정의한다.</p>
<figure>
    <img src="/images/PUP/11.png"/> 
</figure>

<ul>
<li>A : 원본 인접 매트릭스</li>
<li>$M_I$ : 단위 행렬 ( GCN에 self-loop를 추가하는 효과 )</li>
<li>$f(M)$ : 매트릭스 $M$의 각 row의 평균</li>
</ul>
<p>그리고 매트릭스의 출력 표현은 다음과 같다.</p>
<figure>
    <img src="/images/PUP/12.png"/> 
</figure>

<ul>
<li>$F_{in}$ : 입력 원-핫 인코딩 피처 매트릭스( row가 각각의  노드 )</li>
<li>$W$ : 학습 가능한 임베딩 매트릭스</li>
</ul>
<p>임베딩 레이어, 임베딩 전파 레이어, 이웃 집계 레이어를 쌓는 것과 위의 매트릭스 곱의 표현이 동일하다는 것을 증명할 수 있다.</p>
<h2 id="b-how-to-efficiently-perform-decoding">B. How to Efficiently Perform Decoding?</h2>
<p>디코더는 모든 피처 쌍을 내적 해서 계산 복잡도가 상대적으로 높다. 아래의 트릭을 사용해서 선형 복잡도를 가지도록 복잡도를 낮출 수 있다.</p>
<figure>
    <img src="/images/PUP/13.png"/> 
</figure>

<h2 id="c-how-to-prevent-the-model-from-overfitting">C. How to Prevent the Model from Overfitting?</h2>
<p>피처 레벨에 드롭아웃을 적용한다.</p>
<blockquote>
<p>드롭아웃은 오버피팅을 방지하기 위한 효과적인 방법</p>
</blockquote>
<h1 id="5-experiments">5. EXPERIMENTS</h1>
<p>아래의 프로토콜에 따라 제안된 모델을 실험한다.</p>
<ul>
<li>베이스라인과 PUP 모델의 성능을 비교로 가격 인식 추천 시스템 효과 증명</li>
<li>메소드 상에서 가격 요소 역할 분석</li>
<li>가격 인식이 잘 모델링 되었는지 확인하기 위해 두-브랜치 디자인의 효과 분석</li>
<li>카테고리에 따른 가격 인식이 다른 유저의 경우의 성능 테스트</li>
<li>cold-start(미탐색 카테고리 아이템을 추천) 성능 테스트</li>
</ul>
<h2 id="a-experimental-settings">A. Experimental Settings</h2>
<p><strong>1) Dataset and Evaluation Protocol</strong> : 두 실제 데이터셋을 사용해서 성능 비교를 수행한다. 다양한 아이템의 카테고리와 가격 정보가 있는 Yelp와 Beibei를 사용하는데 통계 자료는 Table 1에 요약된다.</p>
<figure>
    <img src="/images/PUP/14.png"/> <figcaption>
            <h4>Table 1</h4>
        </figcaption>
</figure>

<ul>
<li><strong>Yelp2018 Open Dataset</strong> : 레스토랑과 쇼핑몰을 아이템으로 레스토랑의 모든 서브 카테고리를 사용한다. 가격은 네 카테고리로 구분되어 있어 바로 사용한다. 10-Core 세팅(상호 작용 10개 이상)을 적용한다.</li>
<li><strong>Beibei</strong> : 중국 이커머스에서 수집된 데이터셋. 아이템에 모두 카테고리와 가격이 있다. 가격은 10개로 나눈다. 10-Core 세팅을 적용한다.</li>
</ul>
<p>타임 스탬프 순으로 샘플을 정렬해 학습 셋(60%), 검증 셋(20%), 테스트 셋(20%)으로 사용한다. top K 추천의 효과를 검증하기 위해 Recall과 NDCG를 사용한다. 테스트 셋 내 모든 유저에 대한 평균을 리포트한다**.**</p>
<p><strong>2) Baselines</strong> : 모든 메소드에서 동일하게 임베딩 사이즈(64), 학습율(1e-2), 미니 배치(1024), 부정 샘플(1), 에폭(200)을 사용했다.</p>
<ul>
<li>ItemPop : 학습 셋에서 유명도 랭킹</li>
<li>BPR-MF : BPR을 적용한 표준 MF</li>
<li>PaDQ : 가격 정보를 처리한 CMF 기반 추천</li>
<li>FM : 아이템 피처로 가격과 카테고리 정보를 통합한 FM</li>
<li>DeepFM : 이전 FM과 DNN을 앙상블한 모델</li>
<li>GC-MC : GCN 모델</li>
<li>NGCF : GNN 모델</li>
</ul>
<h2 id="b-performance-comparison">B. Performance Comparison</h2>
<p>모든 메소드의 결과를 비교했다.</p>
<ul>
<li>Recall@50</li>
<li>NDCG@50</li>
<li>Recall@100</li>
<li>NDCG@100</li>
</ul>
<p>테이블 2에 베이스라인과 PUP을 비교한 결과가 나온다.</p>
<figure>
    <img src="/images/PUP/15.png"/> <figcaption>
            <h4>Table 2</h4>
        </figcaption>
</figure>

<p><strong>1 ) Incorporating Price into Recommendation Improves the Accuarcy</strong> : 가격 정보를 가지는 모델의 성능이 더 좋다. 이것이 가격 인식 추천의 두 문제가 해결되었다는 것을 의미하지는 않는다.</p>
<p><strong>2) Price Should be Considered More as an Input Rather Than a Target</strong> : PaDQ는 공유된 잠재 팩터로 가격 인식을 예측하는 태스크를 추가한 모델이다. FM은 PaDQ를 능가하고 오히려 BPR-MF 보다 성능이 낮다. 가격은 예측 대상이 아니라 추천의 입력이 되어야 한다는 것을 의미한다.</p>
<p><strong>3) Neural Based Methods and Graph Methods Have an Advantage over Other Methods</strong> : 신경망 기반 모델과 그래프 기반 모델이 성능이 더 좋다.</p>
<p><strong>4) Our Proposed PUP Method Achieves the Best Performance</strong> : 모든 데이터셋에서 최고의 결과를 달성했다.</p>
<h2 id="c-the-effect-of-price-factor">C. The Effect of Price Factor</h2>
<p>가격을 추천에 통합하는 것의 중요성을 검증하기 위해 ablation study를 수행한다.</p>
<ul>
<li>가격을 제거한 모델과의 비교를 진행한다.</li>
<li>가격대를 나누는 quantization 프로세스를 비교 검증한다. 아마존 리뷰에서 수집한 일반 데이터셋으로 실험을 수행한다.</li>
</ul>
<p><strong>1) Ablation Study of Price Factor</strong></p>
<figure>
    <img src="/images/PUP/16.png"/> <figcaption>
            <h4>Table 3</h4>
        </figcaption>
</figure>

<p><strong>2) The Quantization Process of Price Factor</strong></p>
<figure>
    <img src="/images/PUP/17.png"/> <figcaption>
            <h4>Table 4</h4>
        </figcaption>
</figure>

<ul>
<li>Uniform : 최소 가격을 뺀 다음 해당 카테고리의 가격 범위로 나누어 가격을 정규화 한다.</li>
<li>Rank : 카테고리 내 가격 별로 제품을 정렬하고, 랭크를 백분위 수로 변환한다. 마지막으로 가격 수준의 총 수를 곱해서 정수로 만들어 사용한다.</li>
</ul>
<ol start="3">
<li>The Fineness of the Price Factor</li>
</ol>
<figure>
    <img src="/images/PUP/18.png"/> <figcaption>
            <h4>Figure 5</h4>
        </figcaption>
</figure>

<ul>
<li>2 price levels : 저렴한 모델 vs 비싼 모델</li>
</ul>
<h2 id="d-the-two-branch-design">D. The Two-branch Design</h2>
<p>가격 인식의 글로벌 효과와 로컬 효과를 두 브랜치로 구분해 설계했다.  $m/n$은 글로벌 브랜치와 로컬 브랜치에서 사용하는 임베딩 사이즈이다. 글로벌에 많은 차원이 할당된다면 유저의 관심사와 가격의 평균 영향도에 더 많은 집중을 하게 되고 카테고리 브랜치의 경우, 로컬과 카테고리에 의존적인 가격 인식이 더 많은 역할을 하게 된다.</p>
<figure>
    <img src="/images/PUP/19.png"/> <figcaption>
            <h4>Table 5</h4>
        </figcaption>
</figure>

<p>카테고리 브랜치의 아이템 임베딩은 숨겨져 있고 사용자-아이템 상호작용 예측을 할 때 아이템이 중요하기 때문에 글로벌 브랜치가 메인이 되었을 때 성능이 향상되는게 당연하다.</p>
<h2 id="e-consistency-of-price-awareness-across-categories">E. Consistency of Price Awareness across Categories</h2>
<p>CWTPS의 엔트로피 값으로 나눈 서로 다른 유저 그룹들에 대해 DeepFM과 PUP의 결과와 비교한다.</p>
<figure>
    <img src="/images/PUP/20.png"/> <figcaption>
            <h4>Table 6</h4>
        </figcaption>
</figure>

<ul>
<li>???? 결과 뭐야? 모델에서 카테고리 브랜치의 역할이 바로 카테고리에 따른 유저의 가격 인식이 달라지는 것을 목표로 한다.</li>
</ul>
<h2 id="f-utilizing-price-to-tackle-cold-start-problems">F. Utilizing Price to Tackle Cold-Start Problems</h2>
<p>경험해 보지 못한 카테고리에 대한 추천을 제공하는 것은 cold-start 문제로 정의 된다. 가격이 이 상황을 해결 할 수 있다.</p>
<p>검증을 위해 데이터셋에 몇가지 처리를 한다. 학습 셋에서 구매한 카테고리를 테스트 셋에서는 구매하지 않은 유저를 찾는다. 그리고 이러한 아이템을 테스트 셋에서 제거한다. 실험은 두 프로토콜을 따라 수행한다.</p>
<ul>
<li>CIR : 후보 아이템 풀은 테스트 셋에 있는 경험해보지 못한 카테고리(test pos)에 속한 모든 아이템으로 구성된다.</li>
<li>UCIR : 후보 아이템 풀이 학습 셋 내 카테고리(train pos)에 없는 모든 아이템으로 구성된다.</li>
</ul>
<p>전체 카테고리가 A,B,C,D,E,F,G 이고 유저가 A,B,C를 학습 셋에서 구매했고 E가 테스트 셋에 존재한다면</p>
<ul>
<li>CIR : 카테고리 E의 모든 아이템이 후보 셋</li>
<li>UCIR : 카테고리 D,E,F,G의 모든 아이템이 후보 셋</li>
</ul>
<figure>
    <img src="/images/PUP/21.png"/> <figcaption>
            <h4>Figure 6</h4>
        </figcaption>
</figure>

<ul>
<li>$PUP-$ : 카테고리 노드를 제거한 PUP</li>
</ul>
<p>이웃 집계 시, GC-MC는 중간의 유저를 통해 미경험 카테고리의 아이템 노드에 도달할수 있지만, PUP과 PUP-는 가격 노드를 통해 쉽게 도달할 수 있다.</p>
<p>강력한 그래프 컨볼루션 인코더로 인해, 그래프에서는 미탐색 카테고리 노드에 연결된 아이템 노드는 가격 노드와 연결된 유저 노드를 통해 도달할 수 있기 때문에 유저의 고차 이웃 노드이다. 강력한 CF 효과로, 미탐색 카테고리 아이템에 3 홉(유저-아이템-유저-아이템)으로 도달 할 수 있다. 게다가 만약 유저가 여러 가격대의 아이템을 구매했다면, 가격 노드를 통해 도달할 수 있다(유저-아이템-가격-아이템).</p>
<h1 id="7-conclusion-and-future-work">7. CONCLUSION AND FUTURE WORK</h1>
<p>논문에서는 추천에 가격을 통합하는 것이 중요하다는 것을 강조한다. GCN 기반 메소드인 PUP과 두-브랜치 구조로 글로벌하고 로컬한 가격 인식 효과를 분리한 디자인을 제안한다. 실제 데이터셋을 사용해서 검증했다. 기존 메소드에 비해 우월하다는 것을 증명했다. 추가로 콜드 스타트 이슈에 가격 인식을 활용할 수 있다는 인사이트를 제공했다.</p>
<p>본 논문에서는 가격 민감도 모델링에 특화되어 디자인 했지만, 다른 특징들에도 쉽게 통합할 수 있다. 유저 프로파일이 유저 노드와 연결된 노드로 추가되면 되고, 아이템의 특성도 유사하게 적용할 수 있다.</p>
<p>가격의 다이나믹함을 모델링이 추후 연구 과제이다.</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/recommendation/"> recommendation </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Tags</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/beibei/"> beibei </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/gcn/"> gcn </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/gnn/"> gnn </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/price/"> price </a>
			
			
			
			
			
			<a href="/tags/pup/"> pup </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/recsys/"> recsys </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'Slave';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>
<footer>
	 © Copyright notice | <a href="https://github.com/dataCobra/hugo-vitae">Vitae</a> theme for <a href="https://gohugo.io">Hugo</a> 
	
	
	
</footer>


</body>
</html>
