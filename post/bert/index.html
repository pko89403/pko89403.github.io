<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.82.1" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	
	<meta property="og:title" content="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰">
	
	
	<meta name="keywords" content="ai,nlp,bert"><meta name="description" content="BERT : Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰 Abstract BERT라고 부르는 언어 표현 모델을 소개한다. BERT는 Bidirectional …"><meta property="og:title" content="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰" />
<meta property="og:description" content="BERT : Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰 Abstract BERT라고 부르는 언어 표현 모델을 소개한다. BERT는 Bidirectional Encoder Representations from Transfomers를 가리킨다. 최근의 언어 표현 모델들과 다르게, BERT는 모든 레이어 양쪽의 context에 대해 같은 조건으로 라벨링 되지 않은 텍스트로 딥러닝을 사용한 양방향 표현을 사전 학습하도록 설계했다. 사전 학습된 BERT 모델은 질의 응답, 언어 추론과 같은 다양한 태스크에 태스크 별 아키텍처에 대한 수정을 하지 않고 출력 레이어 하나만 추가해서 파인 튜닝 할 수 있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pko89403.github.io/post/bert/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-05-09T19:40:01&#43;09:00" />
<meta property="article:modified_time" content="2021-05-09T19:40:01&#43;09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰"/>
<meta name="twitter:description" content="BERT : Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰 Abstract BERT라고 부르는 언어 표현 모델을 소개한다. BERT는 Bidirectional Encoder Representations from Transfomers를 가리킨다. 최근의 언어 표현 모델들과 다르게, BERT는 모든 레이어 양쪽의 context에 대해 같은 조건으로 라벨링 되지 않은 텍스트로 딥러닝을 사용한 양방향 표현을 사전 학습하도록 설계했다. 사전 학습된 BERT 모델은 질의 응답, 언어 추론과 같은 다양한 태스크에 태스크 별 아키텍처에 대한 수정을 하지 않고 출력 레이어 하나만 추가해서 파인 튜닝 할 수 있다."/>
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
	<link rel="stylesheet" type="text/css" media="screen" href="/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="/css/all.css" />
	<link rel="stylesheet" href="/css/katex.min.css" crossorigin="anonymous">
	<script defer src="/js/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
	<script defer src="/js/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
	<script>
		document.addEventListener("DOMContentLoaded", function() {
			renderMathInElement(document.body, {
				delimiters: [
					{left: "$$", right: "$$", display: true},
					{left: "$", right: "$", display: false}
				]
		});
		});
	</script><title>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰 | 유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?</title>


</head>
<body><header>
	
	<div id="avatar">
		<a href="https://pko89403.github.io/">
		  <img src="/img/Avatar.png" alt="유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?">
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://pko89403.github.io/">유기농은 너무 비싸서 그런데 농약 친 건 어딨나요?</a></h2></div>
	<div id="title-description"><p id="subtitle"><a href=""></a></p><div id="social">
			<nav>
				<ul>
					<li><a href="https://github.com/pko89403"><i title="Github" class="icons fab fa-github"></i></a></li><li><a href="mailto:pko89403@gmail.com"><i title="Email" class="icons fas fa-envelope"></i></a></li></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/">Home</a></li>
				
				<li><a href="/post">All Posts</a></li>
				
				<li><a href="/about">About</a></li>
				
				<li><a href="/tags">Tags</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">09</span>
				<span class="rest">May 2021</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰</h1>
		</div>
	</div>
	<div class="markdown">
		<h1 id="bert--pre-training-of-deep-bidirectional-transformers-for-language-understanding-리뷰">BERT : Pre-training of Deep Bidirectional Transformers for Language Understanding 리뷰</h1>
<h1 id="abstract">Abstract</h1>
<p>BERT라고 부르는 언어 표현 모델을 소개한다. BERT는 Bidirectional Encoder Representations from Transfomers를 가리킨다. 최근의 언어 표현 모델들과 다르게, BERT는 모든 레이어 양쪽의 context에 대해 같은 조건으로 라벨링 되지 않은 텍스트로 딥러닝을 사용한 양방향 표현을 사전 학습하도록 설계했다. 사전 학습된 BERT 모델은 질의 응답, 언어 추론과 같은 다양한 태스크에 태스크 별 아키텍처에 대한 수정을 하지 않고 출력 레이어 하나만 추가해서 파인 튜닝 할 수 있다. 파인튜닝 한 모델은 SOTA 모델이다.</p>
<p>BERT는 개념적으로 강력하다. 11개 NLP 태스크에 새로운 SOTA 결과를 달성했다. GLUE 스코어에 80.5% (절대적인 7.7% 수치 개선), MultiNLI 정확도를 86.7% (4.6% 개선), SQuAD v1.1 질의 응답 테스트 F1 스코어를 93.2 ( 1.5 개선) 그리고 SQuAD v2.0에 F1 83.1(5.1 개선)</p>
<h1 id="1-introduction">1. Introduction</h1>
<p>언어 모델을 사전 학습하는 것은 많은 NLP 태스크의 성능을 향상시키는 효과적인 방법이다. 문장 단위 태스크 인 자언어 추론과 패러프레이징(바꿔쓰기)와 같은 문장 간의 관계를 예측하는 것을 목표로 하고, 개체명 인식과 질의 응답과 같은 토큰 단위의 태스크에서도 토큰 수준에서 구분이 잘된 출력을 생성하는 것을 목표로 한다.</p>
<p>다운스트림 태스크 들에 사전 학습된 언어 표현을 적용하기 위한 두가지 방법은 feature-based와 fine-tuning이 있다. feature-based는 ELMO의 방법과 같다. 태스크에 특화된 아키텍처를 사용해서 추가 feature로 사전 학습된 표현을 사용한다. fine-tuning 접근법은, GPT와 같은데, 태스크 전용의 파라미터를 최소한으로 가지고, 사전 학습된 모든 파라미터로 다운스트림 태스크에 파인튜닝 시킨다. 두가지 접근법은 사전 학습 과정에서 같은 목적 함수를 공유하고, 일반적인 언어 표현을 학습하기 위해 단-방향 언어 모델을 사용한다.</p>
<p>이 논문에서는 현재 기술 들이 사전 학습된 표현들의 힘을 제한한다고 주장하는데, 특히 파인튜닝 접근법에서 그렇다고 한다. 대표적으로 언급하는 한계는 표준으로 사용하는 언어 모델들이 단-방향이기 때문에, 사전 학습에 사용할 아키텍처 선택을 제한한다고 한다. 예를 들어, OpenAI GPT는 left-to-right 아키텍처를 사용했는데, 트랜스포머의 셀프 어텐션 레이어의 내의 모든 토큰에 이전 토큰 만 추가된다. 이러한 제한으로 인해, 문장 수준의 태스크에 완벽하게 최적화가 되지 못하고, 질의 응답과 같은 양 방향의 context와 통합되는 토큰 수준의 태스크에는 파인튜닝 기반의 접근법을 적용하면 성능이 나쁘다고 한다.</p>
<p>본 논문에서는 BERT를 사용해서 파인튜닝 기반 접근법을 개선시켰다. 다음 단어를 예측하는 모델은 직관적으로 생각해보면 양방향으로 구축할 수가 없다. 그렇기 때문에 BERT는 Cloze 태스크 (Taylor, 1953)에서 영감을 받아, &ldquo;마스크 언어 모델(MLM)&rdquo; 사전 학습 목적 함수를 사용해서 이전에 언급된 단-방향 모델의 제약을 완화했다. MLM은 입력의 토큰들 몇개를 마스크 하고, 목적 함수는 context를 기반으로 마스킹 된 단어의 원래 vocabulary 아이디를 예측하는 것이다. left-to-right 언어 모델의 사전 학습과 다르게, MLM 목적함수는 왼쪽과 오른쪽 양쪽의 context를 합한 표현을 가능하게 해서 양방향 트랜스포머를 사전 학습할 수 있게 한다. 추가로 MLM에 &ldquo;next sentence prediction&rdquo; 태스크를 사용해서 텍스트 쌍의 표현을 함께 사전학습한다. 본 논문이 기여한 것들은 아래와 같다.</p>
<ul>
<li>언어 표현 들에서 양방향 사전 학습의 중요성을 증명한다. 사전 학습을 위한 단방향 언어 모델들을 사용하는 것과 다르게, BERT는 딥러닝으로 양방향 표현을 사전 학습에 마스킹 된 언어 모델을 사용한다. 기존의 독립된 left-to-right와 right-to-left 언어 모델들을 독립적으로 학습한 후 약결합하는 기존 방식과 차이가 있다.</li>
<li>사전 학습된 표현들은 태스크에 특화된 아키텍처로 엔지니어링을 많이 할 필요가 없음을 보인다. BERT는 첫번째로 파인 튜닝에 기반해서 문장과 토큰 수준 태스크 모두에서 SOTA를 달성한 언어 표현 모델이다. 특정 태스크에 특화된 특정 아키텍처 보다 우월한 성능을 보인다.</li>
<li>BERT는 열 하나의 NLP 태스크에서 SOTA를 달성했다. 코드와 사전 학습된 모델은 공개 되어 있다.</li>
</ul>
<h1 id="2-related-work">2. Related Work</h1>
<p>일반적인 사전 학습 표현에는 긴 역사가 있다.</p>
<h2 id="21-unsupervised-feature-based-approaches">2.1 Unsupervised Feature-based Approaches</h2>
<p>광범위 하게 적용 할 수 있는 단어 표현을 학습하는 것은 수십년 동안 활발한 연구 분야 였다. 사전 학습된 단어 임베딩들은 근대 NLP 시스템들에서 필수 컴퍼넌트로, 처음 부터 학습된 임베딩에 비해 상당한 개선을 했다. 단어 임베딩 벡터들을 사전 학습 하기 위해서, left-to-right 언어 모델링 목적 함수들이 사용되었고, 여기에서 사용한 목적 함수는 양쪽 context의 정답과 오답을 판단하는 것이다.</p>
<p>이러한 접근법 들은 문장 임베딩들과 문단 임베딩들과 같은 것들로 일반화되어서 세분화 되었다. 문장 표현을 학습하기 위해서, 이전의 연구들은 다음에 올 후보 문장들의 순위를 매기고, 주어진 이전 문장 표현에서 다음 문장 단어를 생성하고, 오토인코더의 노이즈를 제거하는 것들을 목적 함수로 사용했었다.</p>
<p>ELMO와 그 이전 연구는 각기 다른 차원에 대한 기존 단어 임베딩 연구를 일반화 했다. 그 연구들은 left-to-right와 right-to-left 언어 모델에서 context-sensitive 피처들을 뽑아냈다. 각 토큰의 contextual한 표현은 left-to-right와 right-to-left 표현들을 결합하는 것이다. contextual한 단어 임베딩을 태스크에 특화된 기존 아키텍처와 결합하는 ELMO는 질의 응답, 감정 분석, 개체명 인식을 포함한 일곱 개의 주요 NLP 벤치마크에서 SOTA를 달성했다. LSTM을 사용해서 좌우 context에 하나의 단어를 예측하는 태스크로 contextual한 표현을 학습하는 것을 제안했다. ELMO와 유사하게 모델은 feature-based하고 딥러닝스럽게 bidirectional 하지는 않았다. Fedus et al. (2018)이 cloze 태스크가 텍스트 생성 모델에서 robustness를 향상시키는 것을 보였다.</p>
<h2 id="22-unsupervised-fine-tuning-approaches">2.2 Unsupervised Fine-tuning Approaches</h2>
<p>이 연구의 방향성은 라벨링 되지 않은 텍스트로 부터 사전 학습된 단어 임베딩을 생성 하는 것이 목표였다.</p>
<p>최근에는, contextual한 토큰 표현을 생성하는 단어와 문서 인코더는 라벨링 되지 않은 텍스트로 부터 사전학습 되었고 지도 다운스트림 태스크로 파인튜닝 되었다. 이러한 접근법 들의 장점은 초기 학습에 필요한 파라미터가 적다는 것이다. OpenAI GPT는 GLUE 벤치마크로 많은 문장 단위 태스크 들에서 SOTA를 달성했었다. left-to-right 언어 모델링과 오토인코더 목적함수들이 모델의 사전학습에 사용되었다.</p>
<h2 id="23-transfer-learning-from-supervised-data">2.3 Transfer Learning from Supervised Data</h2>
<p>자연어 추론과 기계 번역과 같이 거대한 데이터셋으로 지도 태스크들에서 효과적인 트랜스퍼 러닝을 보여주려는 연구가 있었다. 컴퓨터 비전 연구도 사전 학습된 대규모 모델에서  트랜스퍼 러닝의 중요성을 증명했다. 효과적인 방법으로는 ImageNet으로 사전 학습된 모델을 파인 튜닝하는 것이다.</p>
<h1 id="3-bert">3 BERT</h1>
<p>BERT 프레임워크에는 두가지 스텝을 가진다. <em>pre-training</em>과 <em>fine-tuning.</em> 사전 학습을 하는 동안, 서로 다른 사전 학습 태스크들에 대해서 라벨링 되지 않은 데이터로 모델을 학습 한다. 파인튜닝을 위해 BERT 모델은 먼저 사전 학습된 파라미터들로 초기화 되고, 다운스트림 태스크를 위해 라벨링 된 데이터로 모든 파라미터 들이 파인튜닝 된다. 각 다운스트림 태스크는 사전 학습된 파라미터들로 같이 초기화가 되더라도 별도 태스크 별 파인 튜닝되는 모델들이 있다. 아래 그림 1의 질의-응답 예제는 실행 예제로 사용된다.</p>
<figure>
    <img src="/images/bert/BERT0.png"/> <figcaption>
            <h4>1</h4>
        </figcaption>
</figure>

<p>BERT의 차별점은 서로 다른 태스크에 대해서도 같은 아키텍처를 가진다는 것이다. 사전 학습된 모델 아키텍처와 최종 다운스트림 모델 아키텍처 간 차이가 작다.</p>
<h2 id="model-architecture">Model Architecture</h2>
<p>BERT의 모델 아키텍처는 tensor2tensor 라이브러리에 릴리즈 되어있는 Vaswani et al. (2017)에서 정의된 기존 구현에 기반한 양방향 트랜스포머의 인코더가 여러 개인 아키텍처다. 트랜스포머의 사용이 흔해져서 논문의 구현도 원본과 거의 동일하다. 모델의 아키텍처에 대한 전반적인 배경 설명은 생략 되어있다.</p>
<p>본 논문에서 레이어 수는 L, 히든 사이즈는 H, 그리고 셀프 어텐션 헤드는 A로 표기한다. 기본적으로 두 모델 크기에 대한 결과를 리포트 하는데</p>
<ul>
<li>$BERT_{BASE}$(L=12, H=768, A=12, Total Parameters=110M)</li>
<li>$BERT_{LARGE}$(L=24, H=1024, A=16, Total Parameters=340M)</li>
</ul>
<p>$BERT_{BASE}$는 OpenAI GPT와 같은 크기의 모델인데 비교를 목적으로 선택했다. 그러나 BERT 트랜스포머는 양방향 셀프 어텐션을 사용하고, GPT 트랜스포머는 모든 토큰의 context가 왼쪽으로 부터 추가되는 left-to-right인 제약이 있다.</p>
<figure>
    <img src="/images/bert/BERT1.png"/> <figcaption>
            <h4>2</h4>
        </figcaption>
</figure>

<h2 id="inputoutput-representations">Input/Output Representations</h2>
<p>BERT가 다양한 다운스트림 태스크들을 다루기 위해서, 입력 표현은 하나의 토큰 시퀀스로 하나의 문장과 한 쌍의 문장(예를 들어, Question, Answer)을 명확하게 표현 할 수 있다. 이 작업으로 &ldquo;문장&quot;은 실제 언어적으로 문장이 아니라 임의의 연속적인 텍스트 범위가 될 수 있다. &ldquo;시퀀스&quot;는 BERT에 대한 입력 토큰 시퀀스를 의미하며, 이는 하나의 문장 또는 두개의 문장이 함께 구성될 수 있다.</p>
<p>30,000개의 토큰으로 vocabulary를 구성하고 WordPiece 임베딩을 사용했다. 모든 시퀀스의 첫번째 토큰은 항상 분류 토큰([CLS])이다. 이 토큰에 해당하는 마지막 히든  스테이트는 분류 태스크의 집계 시퀀스 표현으로 사용된다. 한쌍의 문장은 하나의 시퀀스로 합쳐진다. 그리고 두 가지 방법으로 문장을 구분한다. 먼저 시퀀스를 특수 토큰([SEP])으로 구분한다. 다음에 학습된 임베딩을 추가한다. 마지막으로 모든 토큰이 문장 A에 속하는지 B에 속하는지 나타내는 학습된 임베딩을 추가한다. 그림 1과 같이, 입력 임베딩을 E로, 스페셜 [CLS] 토큰의 마지막 히든 벡터를 $C \in R^{H}$로, $i^{th}$ 입력 토큰의 마지막 히든 벡터를 $T_i \in R^H$로 둔다.</p>
<p>주어진 토큰에 대해, 입력 표현은 해당하는 토큰, 세그먼트 및 위치 임베딩을 합산해서 구성된다. 이 구성은 그림 2에 있다.</p>
<figure>
    <img src="/images/bert/BERT2.png"/> <figcaption>
            <h4>3</h4>
        </figcaption>
</figure>

<h2 id="31-pre-training-bert">3.1 Pre-training BERT</h2>
<p>BERT 사전학습에 기존의 left-to-right와 right-to-left 한 단-뱡향 언어 모델을 사용하지는 않는다. 대신에 두가지 비지도 태스크를 사용해서 BERT를 사전학습 한다. 그림 1 왼쪽에 표현된다.</p>
<h3 id="task-1-masked-lm">Task #1: Masked LM</h3>
<p>직관적으로, bidirectional 모델이 left-to-right 모델 이나 left-to-tight 와 right-to-left 모델의 약 결합 보다 훨씬 강력하다고 믿는 것이 합리적이다. 아쉽지만, 표준적인 조건부 언어 모델은 오직 left-to-right 나 right-to-left 으로만 학습 할 수 있다. 양방향 조건부가 각 단어가 간접적으로 see itself( 예측하려는 다음 단어를 참조) 할 수 있고, 그러면 모델이 여러개의 레이어로 된 context에서 타겟 단어를 예측할 수 있었기 때문이다.</p>
<p>양방향 표현을 딥러닝으로 학습을 하기 위해, 입력 토큰 들을 일정 비율로 랜덤하게 마스킹 하고, 그런 마스킹 된 토큰 들을 예측한다. 이런 과정을 마스킹 된 언어 모델(MLM)라고 하지만, Cloze 태스크 라고도 한다. 이런 경우, 마스크 토큰에 해당하는 마지막 히든 벡터는 표준 LM과 같이 vocabulary를 통해 출력 소프트 맥스로 피딩 된다. 논문의 모든 실험에서, 모든 WordPiece 토큰의 15%를 랜덤하게 마스킹한다. 오토 인코더의 노이즈 제거와 반대로, 우리는 전체 입력을 재구성하기 보다는 마스크된 단어를 예측한다.</p>
<p>위의 방법으로 양방향 사전 학습 모델을 얻을 수 있지만, 단점은 있다. [MASK] 토큰이 파인튜닝에서는 나타나지 않기 때문에, 사전 학습과 파인튜닝 간의 미스매치가 발생할 수 있다. 미스매치 문제를 해결하기 위해, 실제로는 [MASK] 토큰을 &ldquo;마스킹 된&rdquo; 단어들로 매번 교체하지는 않는다. 학습 데이터 생성기가 15%의 확률로 토큰 위치를 랜덤하게 선택하고 선택한 토큰을 예측한다. i번째 토큰이 선택되면,</p>
<p>(1) 80%의 확률로 i번째 토큰을 [MASK] 토큰을 교체하고</p>
<p>(2) 10%의 확률로 랜덤한 토큰으로 교체하고</p>
<p>(3) 10%의 확률로 토큰을 교체하지 않고 그대로 둔다.</p>
<p>그러면 $T_i$는 크로스 엔트로피 로스를 가지는 원본 토큰을 예측하는데 사용된다.</p>
<figure>
    <img src="/images/bert/BERT3.png"/> <figcaption>
            <h4>4</h4>
        </figcaption>
</figure>

<h3 id="task-2-next-sentence-prediction-nsp">Task #2: Next Sentence Prediction (NSP)</h3>
<p>자연어 추론(NLI)와 질의 응답(QA)와 같은 많은 중요한 다운 스트림 태스크는 언어 모델링으로는 직접적으로 해결하지 못하는 두 문장의 관계를 이해하는 것에서 부터 시작된다. 문장 관계를 이해하는 모델을 학습하기 위해, 하나의 언어로 구성된 말뭉치에서 생성될 수 있는 이진화된 NSP 태스크를 사전 학습한다. 특히, 각 사전학습 예제에서 문장 A와 B를 선택할 때, 50%의 확률로 B는 실제로 A 다음의 문장이고( IsNext로 라벨링 되고) 50%의 확률로 말뭉치에서 나오는 랜덤 문장이다. ( NotNext로 라벨링 된다 ). 그림 1에서 보이듯, C는 NSP에 사용된다. 태스크는 간단하지만, NSP는 QA와 NLI 모두에 매우 도움이 된다. NSP 태스크는 Jernite et al. (2017)과 Logeswaran and Lee (2018)에서 사용된 표현 학습 목적 함수와 밀접한 관련이 있다. 그러나 이전 연구에서는 문장 임베딩 들만 다운스트림 태스크들에 트랜스퍼 되며, BERT는 마지막 태스크 모델의 파라미터들을 초기화 하는데 모든 파라미터를 트랜스퍼 한다.</p>
<figure>
    <img src="/images/bert/BERT4.png"/> <figcaption>
            <h4>5</h4>
        </figcaption>
</figure>

<h3 id="사전-학습-데이터">사전 학습 데이터</h3>
<p>사전 학습 과정은 주로 언어 모델 사전 학습에 대한 기존 방법을 따른다. 사전학습하는 말뭉치는 BooksCorpus(800M 단어)와 English Wikipedia(2,500M 단어)를 사용했다. 위키피디아는 텍스트 구문을 추출하고 리스트, 테이블, 헤더는 무시한다. 긴 시퀀스들을 추출하기 위해 Billion Word 벤치마크와 같이 뒤섞인 문장 수준의 말뭉치 보다는 문서 수준의 말뭉치를 사용하는 것이 중요하다.</p>
<h3 id="32-fine-tuning-bert">3.2 Fine-tuning BERT</h3>
<p>파인튜닝은 트랜스포머의 셀프 어텐션 메커니즘으로 BERT가 많은 다운스트림 태스크를 모델링 할 수 있어서 간단하다. 태스크가 단일 텍스트를 가지는지? 텍스트 쌍을 포함 하는지?에 따라 적절하게 입력과 출력을 교체 할 수 있다. 텍스트 쌍을 다루는 어플리케이션의 경우, Parikh et al. (2016)과 Seo et al. (2017)과 같이 양방향 교체 어텐션을 적용하기 이전에 텍스트 쌍을 서로에 독립적으로 인코딩하는 것이 일반적인 패턴이다. BERT는 셀프 어텐션 메커니즘을 사용해서 이러한 두 단계를 통합한다. 합쳐진 텍스트 쌍을 셀프 어텐션을 사용해 인코딩하면 두 문장간 양방향 크로스 어텐션이 효과적으로 포함되기 때문이다.</p>
<p>각 태스크 들에 대해서, 태스크 별 입력과 출력을 BERT에 연결하고 end-to-end로 모든 파라미터를 파인튜닝하면 된다. 사전 학습의 입력에서 문장 A와 문장 B는 (1) 페러프레이징의 문장 쌍, (2) 함의에서 가설-전제 쌍, (3) 질의 응답에서 질문-답변 쌍 그리고 (4) 텍스트 분류나 시퀀스 태깅에서의 퇴화된 텍스트-전제 쌍과 유사하다. 출력에서 토큰 표현은 토큰 수준 태스크를 위해 출력 계층으로 피딩되고, [CLS] 표현은 텍스트 함의나 감정 분석과 같은 분류를 위해 출력 레이어로 피딩된다.</p>
<p>사전 학습과 비교해서, 파인 튜닝은 상대적으로 비용이 많이 들지는 않는다. 논문의 모든 결과는 같은 사전 학습된 모델에서 시작해서 클라우드 TPU로 거의 한시간, GPU에서 몇 시간으로 동일한 결과를 낼 수 있도록 파인튜닝 할 수 있다.</p>
<h1 id="4-experiments">4 Experiments</h1>
<p>11개의 NLP 태스크 들에 파인튜닝된 BERT를 제시한다.</p>
<h2 id="41-glue">4.1 GLUE</h2>
<p>GLUE 벤치마크는 다양한 자연어 이해 태스크의 모음이다. GLUE에 파인튜닝을 하기 위해 섹션 3에 묘사된 입력 시퀀스(단일 문장 이나 문장의 쌍)를 표현했고, 첫번째 입력 토큰([CLS])에 해당하는 마지막 히든 벡터 $C \in R^H$를 결합된 표현으로 사용한다. 파인튜닝으로 생성되는 새로운 파라미터들은 분류 레이어로 $W \in R^{K \times H}$로 K는 라벨의 수이다. 표준 분류 로스를 C와 W를 사용해서 계산한다. ( 즉, $log(softmax(CW^T))$ 이다 ).</p>
<p>배치 사이즈 32로 모든 GLUE 태스크 데이터에 3 epoch로 파인튜닝한다. 각 태스크에서, Dev 셋에서 최고의 파인튜닝 학습율(5e-5, 4e-5, 3e-5 그리고 2e-5)을 선택했다. $BERT_{LARGE}$은 작은 데이터셋에는 안정적이지 못해서, 랜덤 재시작을 하고 Dev 셋에 최적인 모델을 선택했다. 랜덤 재시작에는 동일한 사전 학습 체크포인트를 사용했지만, 파인튜닝 데이터 셔플링과 분류 레이어 초기화는 다르게 했다.</p>
<p>결과는 테이블 1에 있다. $BERT_{BASE}$와 $BERT_{LARGE}$는 모든 태스크에서 성능이 좋으며, 상대적인 평균 정확도는 이전 SOTA에 비해 4.5%, 7%가 개선되었다. $BERT_{BASE}$와 OpenAI GPT는 어텐션 마스킹을 제외하고는 모델 아키텍처는 거의 동일하다. MNLI라는 GLUE의 가장 크고 광범위하게 보고된 태스크에서 BERT는 4.6%의 정확도 개선을 보였다. 공식적인 GLUE 리더보드에서, $BERT_{LARGE}$는 점수 80.5를 얻었다. OpenAI GPT는 72.8 였다.</p>
<p>$BERT_{LARGE}$는 $BERT_{BASE}$에 비해 모든 태스크에서 성능이 좋았다. 매우 작은 학습 데이터를 사용했었다.</p>
<figure>
    <img src="/images/bert/BERT5.png"/> <figcaption>
            <h4>6</h4>
        </figcaption>
</figure>

<h2 id="42-squad-v11">4.2 SQuAD v1.1</h2>
<p>SQuAD는 100k 만큼 크라우드 소싱한 질의/응답 쌍이다. 주어진 질문과 답변이 포함된 위키피디아 문단으로 태스크는 문단에서 답변 텍스트 스팬을 예측한다.</p>
<p>그림 1과 같이, 질의 응답 태스크에서, 입력 질문과 문단을 하나로 묶여진 시퀀스로 만들어서, 질문에는 A 임베딩을 사용하고 문단은 B 임베딩을 사용한다. 파인튜닝 중에 시작 벡터 $S \in R^H$와 끝 벡터 $E \in R^H$를 사용했다. 정답 스팬의 시작이 되는 단어 i의 확률은 $T_i$와 S의 내적에 이어서 단락 내 모든 단어들에 대한 소프트맥스로 계산된다.</p>
<figure>
    <img src="/images/bert/BERT6.png"/> <figcaption>
            <h4>7</h4>
        </figcaption>
</figure>

<p>위치 i에서 j 까지의 후보 스팬의 점수는 $S \cdot T_i + E \cdot T_j$ 로 정의되고, j ≥ i인 최대 점수 스팬은 예측에 사용된다. 학습 목적 함수는 정답의 시작과 끝 위치의 log-likelihoods의 합이다. 배치 사이즈 32와 학습율 5e-5로 3 epoch으로 파인튜닝했다.</p>
<p>테이블 2는 상위에 퍼블리시 된 시스템들의 결과를 보여준다. SQuAD 리더보드의 상위 결과에는 최신 정보는 없다. 모델을 학습할 때 공개 데이터를 사용할 수 있다. 그래서 SQuAD에서 파인튜닝을 하기 전 TriviaQA에서 파인튜닝을 하기전에 데이터 확장을 할 수 있다.</p>
<p>논문의 최고 성능의 시스템은 최상위 리더보드 시스템을 앙상블에서 1.5 F1 그리고 단일 시스템에서 1.3 F1의 개선을 보였다. 단일 BERT 모델이 최상위의 앙상블 시스템의 F1 성능을 능가했다. TriviaQA 파인튜닝 없이 0.1-0.4 F1 정도가 감소하였고, 그래도 기존 시스템 보다는 훨씬 우월한 성능을 보였다.</p>
<figure>
    <img src="/images/bert/BERT7.png"/> <figcaption>
            <h4>8</h4>
        </figcaption>
</figure>

<h2 id="43-squad-v20">4.3 SQuAD v2.0</h2>
<p>SQuAD 2.0 태스크는 SQuAD v1.1을 확장한 것으로 짧은 정답은 존재하지 않고 문제를 더 현실에 가깝게 만들었다.</p>
<p>태스크를 위해 SQuAD v1.1 BERT 모델을 확장하는데 간단한 방법을 사용했다. 답변이 없는 질문은 [CLS] 토큰에 시작과 끝이 있는 답변 스팬으로 처리했다. 시작과 끝의 답변 스팬 위치의 확률 공간은 [CLS] 토큰의 위치를 포함되도록 확장되었다. 예측을 위해,</p>
<ul>
<li>답변이 없는 스팬의 점수:$s_{null} = S \cdot C + E \cdot C$</li>
<li>null이 아닌 스팬의 점수: $S_{\hat{i}, j} = max_{j≥i}S \cdot T_i + E \cdot T_j$</li>
</ul>
<p>를 비교한다. $S_{\hat{i}, j} &gt; S_{null} + \tau$ 일때, null이 아닌 답변을 예측한다. 여기서 임계치 $\tau$는 dev 데이터셋에 F1을 최대화 시키는 값으로 선택된다. TriviaQA데이터는 사용하지 않았다. 학습율 5e-5와 배치사이즈 48로 2 epoch으로 파인튜닝했다. 이전 리더보드의 엔트리와 퍼블리시된 연구 들의 결과는 테이블 3에 있다. BERT를 컴포넌트로 사용하는 시스템을 제외하고 이전의 최고 시스템에 비해 F1을 5.1 개선시켰다.</p>
<figure>
    <img src="/images/bert/BERT8.png"/> <figcaption>
            <h4>9</h4>
        </figcaption>
</figure>

<h2 id="44-swag">4.4 SWAG</h2>
<p>SWAG 데이터셋은 113k의 완전한 문장 쌍 예제를 가지고, 상식 추론을 검증하는 태스크다.  주어진 문장에서, 추가로 문장이 주어졌을 때, 태스크는 네가지 선택지 중 다음에 나올 가장 그럴 듯한 문장을 선택한다.</p>
<p>SWAG 데이터셋에 파인튜닝을 할때, 네개의 입력 시퀀스를 구성하고, 각각은 주어진 문장 (문장 A)와 가능한 다음 문장(문장 B)가 결합된 것을 포함한다. 태스크에 특화된 유일한 파라미터들은 [CLS] 토큰 표현과 내적을하는 벡터로, 토큰 표현 C는 소프트맥스로 정규화된 각 선택에 대한 점수를 나타내는 벡터이다.</p>
<p>학습율 2e-5와 배치 크기 16에서 3 epoch으로 파인튜닝한다. 결과는 테이블 4에 있다. $BERT_{LARGE}$가 저자의 베이스라인인 ESIM+ELMO 시스템에 비해 27.1% 그리고 OpenAI GPT에 비해 8.3% 우월한 성능을 보였다.</p>
<figure>
    <img src="/images/bert/BERT9.png"/> <figcaption>
            <h4>10</h4>
        </figcaption>
</figure>

<h1 id="5-ablation-studies">5 Ablation Studies</h1>
<h2 id="51-effect-of-pre-training-tasks">5.1 Effect of Pre-training Tasks</h2>
<p>BERT는 양방향성의 중요성을 증명했다. 증명에는 $BERT_{BASE}$와 같은 사전학습 데이터, 같은 파인튜닝 스키마 그리고 같은 하이퍼 파라미터를 사용 했을 때, 두 사전학습 목적함수를 검증하는 것으로 했다.</p>
<p><strong>No NSP</strong>: MLM을 사용하는 양방향 모델으로 NSP 태스크는 없는 모델이다.</p>
<p><strong>LTR &amp; No NSP</strong>: MLM이 아닌 Left-to-Right LM을 사용해서 학습한 왼쪽 context 만 있는 모델이다. left-only의 제약이 파인튜닝에도 적용되는데, 제거하면 사전학습과 파인튜닝의 미스매치가 발생해서 다운스트림 태스크의 성능을 떨어트리기 때문에 제거 할 수 없다. 게다가 이 모델은 NSP 태스크 없이 사전학습 되었다. 이 모델은 OpenAI GPT와 직접적인 비교가 가능하지만, 더 큰 학습 데이터, 입력 표현 그리고 파인튜닝 스키마의 차이가 있다.</p>
<p>NSP 태스크 영향을 평가한다. NSP를 없애는 것이 QNLI, MNLI, SQuAD 1.1의 성능을 떨어트리는 것으로 결과는 테이블 5에 나온다. 다음으로 &ldquo;No NSP&quot;와 &ldquo;LTR &amp; No NSP&quot;를 비교해서 양방향 표현 학습의 효과를 검증한다. 모든 태스크에서 LTR 모델이 MLM 모델보다 성능이 나빴다. 특히 MRPC와 SQuAD에서 성능이 많이 떨어졌다.</p>
<figure>
    <img src="/images/bert/BERT10.png"/> <figcaption>
            <h4>11</h4>
        </figcaption>
</figure>

<p>SQuAD의 경우, 토큰 레벨의 히든 스테이트에 오른쪽 context가 없기 때문에, LTR 모델의 토큰 예측 성능이 좋지 않다는 것을 직관적으로 알 수 있다. LTR 시스템을 강화하기 위해서, 최상단에 양방향 LSTM을 추가했다. 추가로 SQuAD에서 성능이 확실하게 개선 되었으나 사전학습 된 양방향 모델과 비교해서는 성능이 여전히 나빴다. BiLSTM은 GLUE 태스크의 성능을 감소시킨다.</p>
<p>LTR과 RTL 모델을 따로 학습해서 각 토큰을 결합하는 ELMO는 아래의 세가지 이유로</p>
<ol>
<li>단일 양방향 모델 보다 두배의 비용이 필요하다.</li>
<li>RTL 모델은 QA와 같은 태스크에서 질문에 대한 답변을 함께 고려하지 못한다.</li>
<li>모든 레이어에서 양방향의 context를 사용할 수 있다.</li>
</ol>
<p>양방향 모델 보다는 걍력하지 않다.</p>
<h2 id="52-effect-of-model-size">5.2 Effect of Model Size</h2>
<p>파인튜닝 태스크 정확도로 모델 사이즈의 효과를 알아본다. 각각 다른 레이어 수, 히든 유닛들, 어텐션 헤드를 가지는 BERT 모델들을 학습했다. 하이퍼파라미터와 학습 과정은 이전에 묘사된 것과 같은 것을 사용했다.</p>
<p>테이블 6에 선택된 GLUE 태스크의 결과가 있다. 이 테이블에서 다섯 번의 랜덤 스타트로 파인튜닝한 Dev 셋에 대한 평균 정확도를 리포트 했다. 3,600개의 라벨링 된 학습 예제를 가지고 사전 학습 태스크과는 다른 MPRC 태스크에서도 더 큰 모델이 정확도를 향상시키는 것을 볼수 있다. 기존 연구에 비해 거대한 모델로 이러한 상당한 개선을 달성할 수있다는 것은 꽤나 놀랍다. 예로, Vaswani et al. (2017)의 가장 큰 트랜스포머(L=6, H=1024, A=16)의 인코더는 100M의 파라미터를 가지고 다른 연구에서 찾은 가장 큰 트랜스포머 (L=64, H=512, A=2)은 235M 파라미터를 가지지만, $BERT_{BASE}$는 110M의 파라미터를 가지고 $BERT_{LARGE}$는 340M 개의 파라미터를 가진다.</p>
<p>기계 번역과 언어 모델링과 같은 거대한 스케일 태스크에서 모델 사이즈를 키움으로써 점진적인 개선이 된다는 것을 알려져 있고, 테이블 6에 표시된 학습 데이터의 언어 모델의 perplexity로 증명된다. 모델의 크기를 극한으로 확장시켜서 충분한 사전학습을 한다면, 매우 작은 태스크에서도 큰 개선이 일어난다는 것을 증명한 첫 사례라고 한다. Peters et al. (2018b)은 사전 학습된 양방향 언어 모델의 크기를 두개에서 네개로 늘리는 혼합된 효과를 다운스트림 태스크에서 보였고 Melamud et al. (2016)는 히든 차원 크기를 200에서 600으로 증가시키는 것이 도움이 되지만, 1000 이상으로 늘렸다고 더 이상의 개선을 할 수 없다는 것을 보였다. 이러한 이전 연구들은 feature-based approach에 대해서만 실험을 했다. 이 논문은 모델이 다운스트림 태스크에서 직접 파인튜닝 되고 랜덤하게 초기화된 추가 파라미터를 작게 사용했을때, 태스크 특화 모델들은 다운 스트림 태스크 데이터가 굉장히 작은 경우에도 더 크고 비싼 사전 학습된 표현들의 수혜를 받을 수 있다고 가정한다.</p>
<figure>
    <img src="/images/bert/BERT11.png"/> <figcaption>
            <h4>12</h4>
        </figcaption>
</figure>

<h2 id="53-feature-based-approach-with-bert">5.3 Feature-based Approach with BERT</h2>
<p>지금 까지 제시된 모든 BERT 결과는 사전 학습된 모델에 간단한 분류 레이어가 추가되고, 모든 파라미터들이 다운스트림 태스크에서 동시에 파인튜닝 되는 파인튜닝 접근법을 사용했다. 그러나 피처 기반 접근법에서는, 사전 학습 된 모델에서 고정된 피처들이 추출된다. 특정한 강점이 있는데, 우선, 모든 태스크들이 트랜스포머 인코더 구조로 쉽게 표현되지는 않기 때문에, 태스크에 특화된 모델 아키텍처이 추가되어야 한다. 다음으로, 학습 데이터의 비싼 표현을 미리 한번 계산한 다음, 저렴한 모델을 이 표현 위에서 사용해서 많은 실험을 수행할 수 있는 계산적 이점이 있다.</p>
<p>두가지 접근법을 BERT에 CoNLL-233 개체명 인식(NER) 태스크에 적용해서 비교한다. BERT의 입력에서 케이스가 보존된 WordPiece 모델을 사용하고, 데이터에 의해 공급되는 최대 문서 context를 포함 시킨다. 보통은 태깅 태스크로 이것을 하지만, 출력에서 CRF 레이어를 사용하지 않는다. NER 라벨 셋에대해 토큰 레벨 분류기에 대한 입력으로 첫번째 하위 토큰 표현을 사용한다.</p>
<p>파인 튜닝 접근법을 ablate하기 위해, BERT의 어떤 파라미터도 파인튜닝하지 않고 하나나 그 이상의 레이어에서 활성화를 추출해서 피처 기반 접근법을 적용한다. 이러한 contextual 임베딩은 분류 레이어 전의 두개의 레이어를 가지는 768 차원의 양방향 LSTM의 입력으로 사용된다.</p>
<p>결과는 테이블 7에 있다. $BERT_{LARGE}$는 SOTA 메소드와 경쟁적으로 수행된다. 최고의 성능을 가지는 메소드는 네 개의 히든 레이어를 가지는 사전 학습된 트랜스포머의 토큰 표현 들을 결합하는데, 전체 모델을 파인튜닝 하는 것에 비해 0.3 F1만 감소 되었다. 이것으로 파인튜닝과 피처 기반 접근법 둘 다에 BERT가 효과적임을 증명했다.</p>
<figure>
    <img src="/images/bert/BERT12.png"/> <figcaption>
            <h4>13</h4>
        </figcaption>
</figure>

<h1 id="6-conclusion">6 Conclusion</h1>
<p>언어 모델을 사용한 트랜스퍼 러닝이 성능이 좋기 때문에, 비지도 사전 학습이 많은 언어 이해 시스템의 필수 파트라는 것을 보였다. 특히 이러한 결과들로 낮은 리소스 태스크들도 단방향 딥러닝 아키텍처에서 수혜를 받을 수 있다. 논문의 주요한 기여는 양방향 딥러닝 아키텍처로 이러한 연구 결과를 일반화 해서 광범위한 NLP 태스크를 동일한 사전 학습된 모델에서 성공적으로 처리할 수 있게 했다.</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/paper-review/"> paper-review </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Tags</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/ai/"> ai </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/bert/"> bert </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/nlp/"> nlp </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
		
	</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
	(function() {
	    
	    
	    if (window.location.hostname == "localhost")
	        return;
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    var disqus_shortname = 'Slave';
	    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to load the comments.</noscript>


</div>

  </main>
<footer>
	 © Copyright notice | <a href="https://github.com/dataCobra/hugo-vitae">Vitae</a> theme for <a href="https://gohugo.io">Hugo</a> 
	
	
	
</footer>


</body>
</html>
